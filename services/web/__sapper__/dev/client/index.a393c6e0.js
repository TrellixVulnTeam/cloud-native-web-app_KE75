import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, w as create_slot, D as assign, v as validate_slots, L as exclude_internal_props, e as element, f as claim_element, g as children, b as detach_dev, M as set_attributes, N as toggle_class, k as add_location, j as attr_dev, l as insert_dev, m as append_dev, O as listen_dev, x as update_slot, I as get_spread_update, y as transition_in, z as transition_out, P as bubble, Q as svg_element, t as text, h as claim_text, o as set_data_dev, a as space, c as claim_space, n as noop, R as set_input_value, T as run_all, U as binding_callbacks, V as bind, E as create_component, G as claim_component, H as mount_component, W as add_flush_callback, K as destroy_component, p as validate_store, u as component_subscribe, X as onMount, Y as goto, Z as currentUser, A as empty, C as check_outros, B as group_outros } from './client.4a696408.js';

/* src/components/ui-elements/button.svelte generated by Svelte v3.32.1 */

const file = "src/components/ui-elements/button.svelte";

function create_fragment(ctx) {
	let span;
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	let button_levels = [
		/*$$props*/ ctx[0],
		{ type: "button" },
		{
			class: "inline-flex items-center px-4 py-2 border border-transparent text-sm leading-5 font-medium rounded-md text-white bg-indigo-600 focus:outline-none focus:border-indigo-700 focus:shadow-outline-indigo active:bg-indigo-700"
		}
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			button = element("button");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			button = claim_element(span_nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			if (default_slot) default_slot.l(button_nodes);
			button_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(button, button_data);
			toggle_class(button, "disabled", /*$$props*/ ctx[0].disabled);
			toggle_class(button, "enabled", !/*$$props*/ ctx[0].disabled);
			toggle_class(button, "svelte-ktvd58", true);
			add_location(button, file, 12, 2, 224);
			attr_dev(span, "class", "inline-flex rounded-md shadow-sm");
			add_location(span, file, 11, 0, 174);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, button);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0],
				{ type: "button" },
				{
					class: "inline-flex items-center px-4 py-2 border border-transparent text-sm leading-5 font-medium rounded-md text-white bg-indigo-600 focus:outline-none focus:border-indigo-700 focus:shadow-outline-indigo active:bg-indigo-700"
				}
			]));

			toggle_class(button, "disabled", /*$$props*/ ctx[0].disabled);
			toggle_class(button, "enabled", !/*$$props*/ ctx[0].disabled);
			toggle_class(button, "svelte-ktvd58", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Button", slots, ['default']);

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props, $$scope, slots, click_handler];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment.name
		});
	}
}

/* src/components/ui-elements/input-group.svelte generated by Svelte v3.32.1 */

const file$1 = "src/components/ui-elements/input-group.svelte";

// (20:39) 
function create_if_block_3(ctx) {
	let textarea;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				rows: true,
				placeholder: true,
				class: true
			});

			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(textarea, "rows", "10");
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[4]);
			attr_dev(textarea, "class", "block w-full");
			add_location(textarea, file$1, 20, 4, 533);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[10]),
					listen_dev(textarea, "keypress", /*keypress_handler_1*/ ctx[11], { once: true }, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*placeholder*/ 16) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(20:39) ",
		ctx
	});

	return block;
}

// (18:2) {#if elementType === "input"}
function create_if_block_2(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { id: true, placeholder: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "id", /*id*/ ctx[3]);
			attr_dev(input, "placeholder", /*placeholder*/ ctx[4]);
			attr_dev(input, "class", "block w-full");
			add_location(input, file$1, 18, 4, 388);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[8]),
					listen_dev(input, "keypress", /*keypress_handler*/ ctx[9], { once: true }, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*id*/ 8) {
				attr_dev(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 16) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(18:2) {#if elementType === \\\"input\\\"}",
		ctx
	});

	return block;
}

// (24:2) {#if hasError && isDirty}
function create_if_block_1(ctx) {
	let div;
	let svg;
	let path;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			svg = claim_element(div_nodes, "svg", { class: true, fill: true, viewBox: true }, 1);
			var svg_nodes = children(svg);

			path = claim_element(
				svg_nodes,
				"path",
				{
					"fill-rule": true,
					d: true,
					"clip-rule": true
				},
				1
			);

			children(path).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "fill-rule", "evenodd");
			attr_dev(path, "d", "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z");
			attr_dev(path, "clip-rule", "evenodd");
			add_location(path, file$1, 26, 8, 867);
			attr_dev(svg, "class", "h-5 w-5 text-red-500");
			attr_dev(svg, "fill", "currentColor");
			attr_dev(svg, "viewBox", "0 0 20 20");
			add_location(svg, file$1, 25, 8, 784);
			attr_dev(div, "class", "absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none");
			add_location(div, file$1, 24, 4, 692);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(24:2) {#if hasError && isDirty}",
		ctx
	});

	return block;
}

// (32:2) {#if hasError && isDirty}
function create_if_block(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*errorMessage*/ ctx[5]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*errorMessage*/ ctx[5]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "mt-2 text-sm text-red-600");
			add_location(p, file$1, 32, 4, 1101);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errorMessage*/ 32) set_data_dev(t, /*errorMessage*/ ctx[5]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(32:2) {#if hasError && isDirty}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let div;
	let t2;
	let t3;

	function select_block_type(ctx, dirty) {
		if (/*elementType*/ ctx[1] === "input") return create_if_block_2;
		if (/*elementType*/ ctx[1] === "textarea") return create_if_block_3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);
	let if_block1 = /*hasError*/ ctx[6] && /*isDirty*/ ctx[7] && create_if_block_1(ctx);
	let if_block2 = /*hasError*/ ctx[6] && /*isDirty*/ ctx[7] && create_if_block(ctx);

	const block = {
		c: function create() {
			label_1 = element("label");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			div = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*label*/ ctx[2]);
			label_1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*id*/ ctx[3]);
			attr_dev(label_1, "class", "mt-4 block text-sm font-medium leading-5 text-gray-700");
			add_location(label_1, file$1, 12, 0, 203);
			attr_dev(div, "class", "mt-1 relative rounded-md shadow-sm");
			add_location(div, file$1, 16, 0, 303);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			append_dev(label_1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);

			if (dirty & /*id*/ 8) {
				attr_dev(label_1, "for", /*id*/ ctx[3]);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t2);
				}
			}

			if (/*hasError*/ ctx[6] && /*isDirty*/ ctx[7]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*hasError*/ ctx[6] && /*isDirty*/ ctx[7]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);

			if (if_block0) {
				if_block0.d();
			}

			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Input_group", slots, []);
	let { elementType } = $$props;
	let { label } = $$props;
	let { id } = $$props;
	let { placeholder } = $$props;
	let { value } = $$props;
	let { errorMessage } = $$props;
	let { hasError } = $$props;
	let isDirty = false;

	const writable_props = [
		"elementType",
		"label",
		"id",
		"placeholder",
		"value",
		"errorMessage",
		"hasError"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Input_group> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const keypress_handler = () => $$invalidate(7, isDirty = true);

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const keypress_handler_1 = () => $$invalidate(7, isDirty = true);

	$$self.$$set = $$props => {
		if ("elementType" in $$props) $$invalidate(1, elementType = $$props.elementType);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("errorMessage" in $$props) $$invalidate(5, errorMessage = $$props.errorMessage);
		if ("hasError" in $$props) $$invalidate(6, hasError = $$props.hasError);
	};

	$$self.$capture_state = () => ({
		elementType,
		label,
		id,
		placeholder,
		value,
		errorMessage,
		hasError,
		isDirty
	});

	$$self.$inject_state = $$props => {
		if ("elementType" in $$props) $$invalidate(1, elementType = $$props.elementType);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("errorMessage" in $$props) $$invalidate(5, errorMessage = $$props.errorMessage);
		if ("hasError" in $$props) $$invalidate(6, hasError = $$props.hasError);
		if ("isDirty" in $$props) $$invalidate(7, isDirty = $$props.isDirty);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		value,
		elementType,
		label,
		id,
		placeholder,
		errorMessage,
		hasError,
		isDirty,
		input_input_handler,
		keypress_handler,
		textarea_input_handler,
		keypress_handler_1
	];
}

class Input_group extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			elementType: 1,
			label: 2,
			id: 3,
			placeholder: 4,
			value: 0,
			errorMessage: 5,
			hasError: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input_group",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*elementType*/ ctx[1] === undefined && !("elementType" in props)) {
			console.warn("<Input_group> was created without expected prop 'elementType'");
		}

		if (/*label*/ ctx[2] === undefined && !("label" in props)) {
			console.warn("<Input_group> was created without expected prop 'label'");
		}

		if (/*id*/ ctx[3] === undefined && !("id" in props)) {
			console.warn("<Input_group> was created without expected prop 'id'");
		}

		if (/*placeholder*/ ctx[4] === undefined && !("placeholder" in props)) {
			console.warn("<Input_group> was created without expected prop 'placeholder'");
		}

		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
			console.warn("<Input_group> was created without expected prop 'value'");
		}

		if (/*errorMessage*/ ctx[5] === undefined && !("errorMessage" in props)) {
			console.warn("<Input_group> was created without expected prop 'errorMessage'");
		}

		if (/*hasError*/ ctx[6] === undefined && !("hasError" in props)) {
			console.warn("<Input_group> was created without expected prop 'hasError'");
		}
	}

	get elementType() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set elementType(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessage() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hasError() {
		throw new Error("<Input_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hasError(value) {
		throw new Error("<Input_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/new-blog-post.svelte generated by Svelte v3.32.1 */
const file$2 = "src/components/new-blog-post.svelte";

// (46:4) <Button disabled={isPublishDisabled}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Publish");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Publish");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(46:4) <Button disabled={isPublishDisabled}>",
		ctx
	});

	return block;
}

// (51:25) 
function create_if_block_1$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*errorMessage*/ ctx[4]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*errorMessage*/ ctx[4]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "mt-2 text-sm text-red-600");
			add_location(p, file$2, 51, 4, 1284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(51:25) ",
		ctx
	});

	return block;
}

// (49:2) {#if successMessage}
function create_if_block$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*successMessage*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*successMessage*/ ctx[2]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "mt-2 text-sm");
			add_location(p, file$2, 49, 4, 1209);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*successMessage*/ 4) set_data_dev(t, /*successMessage*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(49:2) {#if successMessage}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let h1;
	let t0;
	let t1;
	let div;
	let form;
	let inputgroup0;
	let updating_value;
	let t2;
	let inputgroup1;
	let updating_value_1;
	let t3;
	let button;
	let t4;
	let current;
	let mounted;
	let dispose;

	function inputgroup0_value_binding(value) {
		/*inputgroup0_value_binding*/ ctx[6].call(null, value);
	}

	let inputgroup0_props = {
		elementType: "input",
		label: "Title",
		errorMessage: "Please provide a title.",
		hasError: !/*title*/ ctx[0],
		id: "title",
		placeholder: "Untitled"
	};

	if (/*title*/ ctx[0] !== void 0) {
		inputgroup0_props.value = /*title*/ ctx[0];
	}

	inputgroup0 = new Input_group({ props: inputgroup0_props, $$inline: true });
	binding_callbacks.push(() => bind(inputgroup0, "value", inputgroup0_value_binding));

	function inputgroup1_value_binding(value) {
		/*inputgroup1_value_binding*/ ctx[7].call(null, value);
	}

	let inputgroup1_props = {
		elementType: "textarea",
		label: "Content",
		errorMessage: "Please provide content.",
		hasError: !/*content*/ ctx[1],
		id: "content",
		placeholder: "Your content..."
	};

	if (/*content*/ ctx[1] !== void 0) {
		inputgroup1_props.value = /*content*/ ctx[1];
	}

	inputgroup1 = new Input_group({ props: inputgroup1_props, $$inline: true });
	binding_callbacks.push(() => bind(inputgroup1, "value", inputgroup1_value_binding));

	button = new Button({
			props: {
				disabled: /*isPublishDisabled*/ ctx[3],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	function select_block_type(ctx, dirty) {
		if (/*successMessage*/ ctx[2]) return create_if_block$1;
		if (/*errorMessage*/ ctx[4]) return create_if_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Add new blog post");
			t1 = space();
			div = element("div");
			form = element("form");
			create_component(inputgroup0.$$.fragment);
			t2 = space();
			create_component(inputgroup1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
			t4 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Add new blog post");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			form = claim_element(div_nodes, "FORM", {});
			var form_nodes = children(form);
			claim_component(inputgroup0.$$.fragment, form_nodes);
			t2 = claim_space(form_nodes);
			claim_component(inputgroup1.$$.fragment, form_nodes);
			t3 = claim_space(form_nodes);
			claim_component(button.$$.fragment, form_nodes);
			form_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$2, 24, 0, 627);
			add_location(form, file$2, 26, 2, 675);
			attr_dev(div, "class", "mt-6");
			add_location(div, file$2, 25, 0, 654);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, form);
			mount_component(inputgroup0, form, null);
			append_dev(form, t2);
			mount_component(inputgroup1, form, null);
			append_dev(form, t3);
			mount_component(button, form, null);
			append_dev(div, t4);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "click", /*publish*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const inputgroup0_changes = {};
			if (dirty & /*title*/ 1) inputgroup0_changes.hasError = !/*title*/ ctx[0];

			if (!updating_value && dirty & /*title*/ 1) {
				updating_value = true;
				inputgroup0_changes.value = /*title*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			inputgroup0.$set(inputgroup0_changes);
			const inputgroup1_changes = {};
			if (dirty & /*content*/ 2) inputgroup1_changes.hasError = !/*content*/ ctx[1];

			if (!updating_value_1 && dirty & /*content*/ 2) {
				updating_value_1 = true;
				inputgroup1_changes.value = /*content*/ ctx[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			inputgroup1.$set(inputgroup1_changes);
			const button_changes = {};
			if (dirty & /*isPublishDisabled*/ 8) button_changes.disabled = /*isPublishDisabled*/ ctx[3];

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(inputgroup0.$$.fragment, local);
			transition_in(inputgroup1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(inputgroup0.$$.fragment, local);
			transition_out(inputgroup1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			destroy_component(inputgroup0);
			destroy_component(inputgroup1);
			destroy_component(button);

			if (if_block) {
				if_block.d();
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let isPublishDisabled;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("New_blog_post", slots, []);
	let title;
	let content;
	let successMessage;
	let errorMessage;

	const publish = () => {
		const slug = title.replace(/\s/g, "-").toLowerCase();

		window.db.collection("posts").doc(slug).set({ title, content }).then(() => {
			$$invalidate(2, successMessage = "Successfully published your blog post.");
		}).catch(error => {
			cerrorMessage = "Oh no... there was an error publishing. Try again later.";
		});
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<New_blog_post> was created with unknown prop '${key}'`);
	});

	function inputgroup0_value_binding(value) {
		title = value;
		$$invalidate(0, title);
	}

	function inputgroup1_value_binding(value) {
		content = value;
		$$invalidate(1, content);
	}

	$$self.$capture_state = () => ({
		Button,
		InputGroup: Input_group,
		title,
		content,
		successMessage,
		errorMessage,
		publish,
		isPublishDisabled
	});

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("content" in $$props) $$invalidate(1, content = $$props.content);
		if ("successMessage" in $$props) $$invalidate(2, successMessage = $$props.successMessage);
		if ("errorMessage" in $$props) $$invalidate(4, errorMessage = $$props.errorMessage);
		if ("isPublishDisabled" in $$props) $$invalidate(3, isPublishDisabled = $$props.isPublishDisabled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title, content*/ 3) {
			 $$invalidate(3, isPublishDisabled = !(title && content));
		}
	};

	return [
		title,
		content,
		successMessage,
		isPublishDisabled,
		errorMessage,
		publish,
		inputgroup0_value_binding,
		inputgroup1_value_binding
	];
}

class New_blog_post extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "New_blog_post",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/routes/admin/index.svelte generated by Svelte v3.32.1 */
const file$3 = "src/routes/admin/index.svelte";

// (14:0) {#if $currentUser}
function create_if_block_1$2(ctx) {
	let h1;
	let t0;
	let t1;
	let p;
	let t2;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Admin dashboard");
			t1 = space();
			p = element("p");
			t2 = text("Only authenticated users have access to this.");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Admin dashboard");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t2 = claim_text(p_nodes, "Only authenticated users have access to this.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$3, 14, 2, 330);
			add_location(p, file$3, 15, 2, 357);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(14:0) {#if $currentUser}",
		ctx
	});

	return block;
}

// (19:0) {#if $currentUser}
function create_if_block$2(ctx) {
	let newblogpost;
	let current;
	newblogpost = new New_blog_post({ $$inline: true });

	const block = {
		c: function create() {
			create_component(newblogpost.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(newblogpost.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(newblogpost, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(newblogpost.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(newblogpost.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(newblogpost, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(19:0) {#if $currentUser}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$currentUser*/ ctx[0] && create_if_block_1$2(ctx);
	let if_block1 = /*$currentUser*/ ctx[0] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$currentUser*/ ctx[0]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$2(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*$currentUser*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*$currentUser*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $currentUser;
	validate_store(currentUser, "currentUser");
	component_subscribe($$self, currentUser, $$value => $$invalidate(0, $currentUser = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Admin", slots, []);

	onMount(() => {
		if (!$currentUser) {
			goto("/auth/login?redirect=admin");
		}
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Admin> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		goto,
		onMount,
		currentUser,
		NewBlogPost: New_blog_post,
		$currentUser
	});

	return [$currentUser];
}

class Admin extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Admin",
			options,
			id: create_fragment$3.name
		});
	}
}

export default Admin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYTM5M2M2ZTAuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3VpLWVsZW1lbnRzL2J1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy91aS1lbGVtZW50cy9pbnB1dC1ncm91cC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9uZXctYmxvZy1wb3N0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvYWRtaW4vaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzdHlsZT5cbiAgLmRpc2FibGVkIHtcbiAgICBAYXBwbHkgb3BhY2l0eS01MCBjdXJzb3Itbm90LWFsbG93ZWQ7XG4gIH1cblxuICAuZW5hYmxlZDpob3ZlciB7XG4gICAgQGFwcGx5IGJnLWluZGlnby01MDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxzcGFuIGNsYXNzPVwiaW5saW5lLWZsZXggcm91bmRlZC1tZCBzaGFkb3ctc21cIj5cbiAgPGJ1dHRvblxuICAgIHsuLi4kJHByb3BzfVxuICAgIHR5cGU9XCJidXR0b25cIlxuICAgIGNsYXNzPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHB4LTQgcHktMiBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHRleHQtc20gbGVhZGluZy01IGZvbnQtbWVkaXVtIHJvdW5kZWQtbWQgdGV4dC13aGl0ZSBiZy1pbmRpZ28tNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpib3JkZXItaW5kaWdvLTcwMCBmb2N1czpzaGFkb3ctb3V0bGluZS1pbmRpZ28gYWN0aXZlOmJnLWluZGlnby03MDBcIlxuICAgIGNsYXNzOmRpc2FibGVkPXskJHByb3BzLmRpc2FibGVkfVxuICAgIGNsYXNzOmVuYWJsZWQ9eyEkJHByb3BzLmRpc2FibGVkfVxuICAgIG9uOmNsaWNrID5cbiAgICA8c2xvdCAvPlxuICA8L2J1dHRvbj5cbjwvc3Bhbj4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGVsZW1lbnRUeXBlO1xuICBleHBvcnQgbGV0IGxhYmVsO1xuICBleHBvcnQgbGV0IGlkO1xuICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyO1xuICBleHBvcnQgbGV0IHZhbHVlO1xuICBleHBvcnQgbGV0IGVycm9yTWVzc2FnZTtcbiAgZXhwb3J0IGxldCBoYXNFcnJvcjtcblxuICBsZXQgaXNEaXJ0eSA9IGZhbHNlO1xuPC9zY3JpcHQ+XG5cbjxsYWJlbCBmb3I9e2lkfSBjbGFzcz1cIm10LTQgYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSBsZWFkaW5nLTUgdGV4dC1ncmF5LTcwMFwiPlxuICB7bGFiZWx9XG48L2xhYmVsPlxuXG48ZGl2IGNsYXNzPVwibXQtMSByZWxhdGl2ZSByb3VuZGVkLW1kIHNoYWRvdy1zbVwiPlxuICB7I2lmIGVsZW1lbnRUeXBlID09PSBcImlucHV0XCJ9XG4gICAgPGlucHV0IGJpbmQ6dmFsdWUge2lkfSB7cGxhY2Vob2xkZXJ9IGNsYXNzPVwiYmxvY2sgdy1mdWxsXCIgb246a2V5cHJlc3N8b25jZT17KCkgPT4gaXNEaXJ0eSA9IHRydWV9IC8+XG4gIHs6ZWxzZSBpZiBlbGVtZW50VHlwZSA9PT0gXCJ0ZXh0YXJlYVwifVxuICAgIDx0ZXh0YXJlYSBiaW5kOnZhbHVlIHJvd3M9XCIxMFwiIHtwbGFjZWhvbGRlcn0gY2xhc3M9XCJibG9jayB3LWZ1bGxcIiBvbjprZXlwcmVzc3xvbmNlPXsoKSA9PiBpc0RpcnR5ID0gdHJ1ZX0+PC90ZXh0YXJlYT5cbiAgey9pZn1cblxuICB7I2lmIGhhc0Vycm9yICYmIGlzRGlydHl9XG4gICAgPGRpdiBjbGFzcz1cImFic29sdXRlIGluc2V0LXktMCByaWdodC0wIHByLTMgZmxleCBpdGVtcy1jZW50ZXIgcG9pbnRlci1ldmVudHMtbm9uZVwiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwiaC01IHctNSB0ZXh0LXJlZC01MDBcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiPlxuICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xOCAxMGE4IDggMCAxMS0xNiAwIDggOCAwIDAxMTYgMHptLTcgNGExIDEgMCAxMS0yIDAgMSAxIDAgMDEyIDB6bS0xLTlhMSAxIDAgMDAtMSAxdjRhMSAxIDAgMTAyIDBWNmExIDEgMCAwMC0xLTF6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICB7L2lmfVxuXG4gIHsjaWYgaGFzRXJyb3IgJiYgaXNEaXJ0eX1cbiAgICA8cCBjbGFzcz1cIm10LTIgdGV4dC1zbSB0ZXh0LXJlZC02MDBcIj57ZXJyb3JNZXNzYWdlfTwvcD5cbiAgey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBCdXR0b24gZnJvbSAnLi91aS1lbGVtZW50cy9idXR0b24uc3ZlbHRlJztcbiAgaW1wb3J0IElucHV0R3JvdXAgZnJvbSAnLi91aS1lbGVtZW50cy9pbnB1dC1ncm91cC5zdmVsdGUnO1xuXG4gIGxldCB0aXRsZTtcbiAgbGV0IGNvbnRlbnQ7XG4gIGxldCBzdWNjZXNzTWVzc2FnZTtcbiAgbGV0IGVycm9yTWVzc2FnZTtcblxuICAkOiBpc1B1Ymxpc2hEaXNhYmxlZCA9ICEodGl0bGUgJiYgY29udGVudCk7XG5cbiAgY29uc3QgcHVibGlzaCA9ICgpID0+IHtcbiAgICBjb25zdCBzbHVnID0gdGl0bGUucmVwbGFjZSgvXFxzL2csIFwiLVwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIHdpbmRvdy5kYi5jb2xsZWN0aW9uKFwicG9zdHNcIikuZG9jKHNsdWcpLnNldCh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb250ZW50XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHN1Y2Nlc3NNZXNzYWdlID0gXCJTdWNjZXNzZnVsbHkgcHVibGlzaGVkIHlvdXIgYmxvZyBwb3N0LlwiO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBjZXJyb3JNZXNzYWdlID0gXCJPaCBuby4uLiB0aGVyZSB3YXMgYW4gZXJyb3IgcHVibGlzaGluZy4gVHJ5IGFnYWluIGxhdGVyLlwiO1xuICAgIH0pO1xuICB9O1xuPC9zY3JpcHQ+XG5cbjxoMT5BZGQgbmV3IGJsb2cgcG9zdDwvaDE+XG48ZGl2IGNsYXNzPVwibXQtNlwiPlxuICA8Zm9ybSBvbjpjbGljaz17cHVibGlzaH0+XG4gICAgPElucHV0R3JvdXAgXG4gICAgZWxlbWVudFR5cGU9XCJpbnB1dFwiIFxuICAgIGxhYmVsPVwiVGl0bGVcIiBcbiAgICBlcnJvck1lc3NhZ2U9XCJQbGVhc2UgcHJvdmlkZSBhIHRpdGxlLlwiXG4gICAgaGFzRXJyb3I9eyF0aXRsZX1cbiAgICBpZD1cInRpdGxlXCIgXG4gICAgcGxhY2Vob2xkZXI9XCJVbnRpdGxlZFwiIFxuICAgIGJpbmQ6dmFsdWU9e3RpdGxlfSAvPlxuXG4gICAgPElucHV0R3JvdXAgXG4gICAgZWxlbWVudFR5cGU9XCJ0ZXh0YXJlYVwiIFxuICAgIGxhYmVsPVwiQ29udGVudFwiIFxuICAgIGVycm9yTWVzc2FnZT1cIlBsZWFzZSBwcm92aWRlIGNvbnRlbnQuXCJcbiAgICBoYXNFcnJvcj17IWNvbnRlbnR9XG4gICAgaWQ9XCJjb250ZW50XCIgXG4gICAgcGxhY2Vob2xkZXI9XCJZb3VyIGNvbnRlbnQuLi5cIiBcbiAgICBiaW5kOnZhbHVlPXtjb250ZW50fSAvPlxuXG4gICAgPEJ1dHRvbiBkaXNhYmxlZD17aXNQdWJsaXNoRGlzYWJsZWR9PlB1Ymxpc2g8L0J1dHRvbj5cbiAgPC9mb3JtPlxuXG4gIHsjaWYgc3VjY2Vzc01lc3NhZ2V9XG4gICAgPHAgY2xhc3M9XCJtdC0yIHRleHQtc21cIj57c3VjY2Vzc01lc3NhZ2V9PC9wPlxuICB7OmVsc2UgaWYgZXJyb3JNZXNzYWdlfVxuICAgIDxwIGNsYXNzPVwibXQtMiB0ZXh0LXNtIHRleHQtcmVkLTYwMFwiPntlcnJvck1lc3NhZ2V9PC9wPlxuICB7L2lmfVxuPC9kaXY+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ290byB9IGZyb20gJ0BzYXBwZXIvYXBwJztcbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgY3VycmVudFVzZXIgfSBmcm9tIFwiLi4vLi4vc3RvcmVzL3VzZXJcIjtcbiAgaW1wb3J0IE5ld0Jsb2dQb3N0IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL25ldy1ibG9nLXBvc3Quc3ZlbHRlXCI7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKCEkY3VycmVudFVzZXIpIHtcbiAgICAgIGdvdG8oXCIvYXV0aC9sb2dpbj9yZWRpcmVjdD1hZG1pblwiKVxuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxueyNpZiAkY3VycmVudFVzZXJ9XG4gIDxoMT5BZG1pbiBkYXNoYm9hcmQ8L2gxPlxuICA8cD5Pbmx5IGF1dGhlbnRpY2F0ZWQgdXNlcnMgaGF2ZSBhY2Nlc3MgdG8gdGhpcy48L3A+XG57L2lmfVxuXG57I2lmICRjdXJyZW50VXNlcn1cbiAgPE5ld0Jsb2dQb3N0IC8+XG57L2lmfSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O2NBWVEsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBR0ssR0FBTyxJQUFDLFFBQVE7Z0RBQ2hCLEdBQU8sSUFBQyxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0FKNUIsR0FBTzs7Ozs7OztnREFHSyxHQUFPLElBQUMsUUFBUTtnREFDaEIsR0FBTyxJQUFDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
